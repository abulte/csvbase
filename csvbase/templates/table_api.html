{# -*- mode: jinja2 -*- #}
{% extends "table.html" %}

{% block tab_contents %}
  <div class="container">

    <h2>Table of contents</h2>
    <ol>
      <li>
        <a href="#the-basics">The basics: auth and content negotations</a>
        <ol>
          <li><a href="#authentication">Authentication</a></li>
          <li><a href="#content-negotiation">Content negotiation</a></li>
        </ol>
      </li>
      <li>
        <a href="#the-api">The API: endpoint-by-endpoint</a>
        <ol>
          <li>
            <a href="#tables">Tables</a>
            <ol>
              <li><a href="#table-reading">Reading a table</a></li>
            </ol>
          </li>
          <li>
            <a href="#rows">Rows</a>
            <ol>
              <li><a href="#rows-creating">Creating a new row</a></li>
              <li><a href="#rows-reading">Reading a row</a></li>
              <li><a href="#rows-updating">Updating an existing row</a></li>
              <li><a href="#rows-deleting">Deleting a row</a></li>
            </ol>
          </li>
        </ol>
      </li>
    </ol>

    <h2 id="the-basics">The basics: auth and content negotiation</h2>
    <h3 id="authentication">Authentication</h3>
    <p>
      On CSVBase, you authenticate using by putting your username and API key
      in the url itself (known
      as <a href="https://en.wikipedia.org/wiki/Basic_access_authentication">&quot;HTTP
      basic auth&quot;</a>).
    </p>

    <p>
      {% if table.is_public %}
        {{username}}/{{table_name}} is public so auth is needed only for <em>writes</em>.
      {% else %}
        {{username}}/{{table_name}} is private so auth is needed for all access.
      {% endif %}
    </p>

    <p>
      Your API key is <code>{{ user.hex_api_key() }}</code> and this has been
      inserted where required in all the below examples.
    </p>

    <h3 id="content-negotiation">Content negotiation</h3>
    <p>
      CSVBase APIs use <em>content negotiation</em> to decide what formats are in use.
    </p>

    <p>
      This means it is important that you set the <code>Content-Type</code>
      and <code>Accept</code> headers to be the mimetype you want: typically
      that is <code>application/json</code> for both.  If you fail to include
      these headers in your requests CSVBase will pick a (hopefully) sensible
      default where possible.
    </p>

    <p>
      You can bypass content negotiation for read-only requests by appending a
      file extension to the url, eg <code>.json</code>.  This is useful when
      dealing with software where you aren&apos;t able to set headers at
      all <em>but should be a last resort.</em>
    </p>

    <h2 id="the-api">The API: endpoint-by-endpoint</h2>
    <p>There are three kinds of thing in csvbase:</p>

    <ol>
      <li>users</li>
      <li>tables</li>
      <li>rows</li>
    </ol>

    <p>While there&apos;s no API for users so far, there is for tables and rows.</p>

    <h3 id="tables">Tables</h3>
    <p>(incomplete)</p>
    <h4 id="table-reading">Reading a table</h4>
    <p>(incomplete)</p>

    <h3 id="rows">Rows</h3>
    <p>
      Rows from {{username}}/{{table_name}} look like this is JSON:
    </p>

    <pre>{{ row_to_json_dict(1, sample_row)|ppjson }}</pre>

    <h4 id="rows-creating">Creating a new row</h4>
    <p>
      <code>POST</code> to <code>{{ url_for('csvbase.create_row', username=username, table_name=table_name, _external=True) }}</code>
    </p>

    <h5>Example body</h5>
    <pre>{{ row_to_json_dict(1, sample_row, omit_row_id=True)|ppjson }}</pre>

    <h5>Example response</h5>
    <pre>{{ row_to_json_dict(1, sample_row, omit_row_id=False)|ppjson }}</pre>

    <p>
      Status code 201 upon success.
    </p>

    <h4 id="rows-reading">Reading a row</h4>
    <p>
      <code>GET</code> from <code>{{ url_for('csvbase.get_row', username=username, table_name=table_name, _external=True, row_id=1) }}</code>
    </p>

    <p>No body is provided with this request.  Status code 200 upon success.</p>

    <h5>Example response</h5>
    <pre>{{ row_to_json_dict(1, sample_row, omit_row_id=False)|ppjson }}</pre>

    <h4 id="rows-updating">Updating an existing row</h4>
    <p>
      <code>PUT</code> to <code>{{ url_for('csvbase.update_row', username=username, table_name=table_name, _external=True, row_id=1) }}</code>
    </p>

    <h5>Example body</h5>
    <pre>{{ row_to_json_dict(1, sample_row)|ppjson }}</pre>

    <h5>Response</h5>
    <p>
      Upon success the body you sent will be echoed back, with status code 200.
    </p>

    <h4 id="rows-deleting">Deleting a row</h4>
    <p>
      <code>DELETE</code> from <code>{{ url_for('csvbase.delete_row', username=username, table_name=table_name, _external=True, row_id=1) }}</code>
    </p>

    <p>No body is required.  Status code 204 upon success.</p>

    {# <h3>Table metadata</h3> #}
    {# <h4>Getting the table metadata</h4> #}
    {# <h4>Updating the table metadata</h4> #}



    {# <h3>Getting the dataset</h3> #}
    {# <p>To download the dataset, just use it&apos;s url - the same as on the website</p> #}
    {# <pre>curl {{table_url}}</pre> #}
    {# <p>Or to save it to a file with curl, do:</p> #}
    {# <pre>curl {{table_url}} -o {{table_name|snake_case}}.csv</pre> #}
    {# <h3>Updating the dataset</h3> #}
    {# <p>After changing the dataset, send it back with the <code>PUT</code> HTTP Verb (as CSV)</p> #}
    {# <pre>{%if g.username == username %}# your api key has been filled in here #}
{# {% endif %}curl -XPUT {{private_table_url}} --data-binary @{{table_name|snake_case}}.csv</pre> #}
  </div>
{% endblock %}

